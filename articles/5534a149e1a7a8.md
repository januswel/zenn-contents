---
title: "自動テストの戦略と戦術"
emoji: "💯"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["test"]
published: true
publication_name: "beingish"
---

聞かれることが多いので文章としてまとめておく。もちろん異なるスタンスの方もいるので絶対的なものではない。参考にする場合は自己責任で。

なお、戦術という言葉は「コードベースに携わるチームが目標を達成するためのレイヤー」という意味で、戦略という言葉は「チームも含めた集団全体の目標を達成するためのレイヤー」という意味で使っている。裏返すと、ここで戦略として書いたことはエンジニアでなくても理解できる内容となっている。

# 3 行まとめ

## 戦略

1. 常に目的をはっきりさせる
   - 品質保証
   - 動く仕様書
   - 設計のためのツール
1. 全自動化にこだわらない
   - [ドッグフーディング](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)
1. CI
1. コアドメイン最優先
   - カバレッジ 100% であるべき
   - 全チームメンバーが理解しているべき
     - モブプロ
     - レビュアー

## 戦術

1. テスティングトロフィー
1. フレームワークや UI ライブラリーが密接に絡む箇所は Humble Object の考え方を使う
1. 分割統治

- モックとの付き合い方
  - 外部とのインタラクションが発生する部分
    - ネットワーク通信

# 戦略

## 常に目的をはっきりさせる

あるコードベースに自動テストが存在することは、人間にとって次の旨みがある。

1. 品質保証
1. 動く仕様書
1. 設計のためのツール

### 品質保証

自動テストは[品質保証](https://en.wikipedia.org/wiki/Quality_assurance)の一部、ソフトウェアテストのさらに一部として定義されている。そのため、やるかやらないかではなく「どこまでやるか」を決めることになる。

存在する自動テストをすべてパスしていればプロダクトの目標を達成している、これが理想の状態だ。ただし現代で理想を実現するのは現実的に不可能なので、組織目標とコストを勘案しながら決めることになる。

:::details 理想の実現が不可能な理由
最も大きいのは人間への理解が十分でないため、目標を定めづらいことだろう。現状、プロダクトごとにユーザーリサーチが必要になるということは求める品質がわかりきっていないことの証左だ。人間がどのように変化するかも含めての理解が人類になければ、自動化は不可能だ。

また、理想を実現するために必要なコストが莫大となることも現実的な課題だ。目標を達成しているかの検証を自動化するのはコストパフォーマンスが低い。
:::

他の目標との兼ね合いもあるが、おおむね次に挙げる段階があるだろう。

1. 書けるところだけ書く
   - テストハーネスの学習も込み
1. コアドメインのテストを書く
1. UI のテストを書く
1. UX を可視化する

#### 書けるところだけ書く

自動テストを書くというのはひとつのスキルだ。習得するために学習や経験が必要となる。その際のトピックとして主に次が挙げられるが、まったく網羅できているリストではない。

- 基礎
  1. テストハーネスの導入
     - テスティングフレームワークの導入と初期設定
     - テスト用ライブラリーのインストールと設定
  1. テストハーネスの使い方
     - テストの書き方
     - テストの実行方法
       - 必要なテストのみ実行する方法
  1. [テストサイズ](https://testing.googleblog.com/2010/12/test-sizes.html)の概念
  1. [テストカバレッジ](https://en.wikipedia.org/wiki/Code_coverage)
     - カバレッジ基準
- 発展
  1. モックの使い方
     - 接合モデル
  1. UI のテスト
     - [ハンブルオブジェクト](https://martinfowler.com/bliki/HumbleObject.html)
  1. テストがないコードベースにテストを追加する
     - [スプラウト系](https://dev.to/edgaremmanuel/changing-software-sprout-method-1iok)

これだけ多いとハードルが高く感じられるが、まず基礎を確実に抑えよう。発展トピックはそれぞれ必要になったら学ぶで良い。

最初からすべてのテストケースがわかっていることはまずない。トラブルなどからテストケースを追加することによって徐々にコードベースの信頼性が上がっていくため、想像をベースに作り込むよりも、テストを書くための土台のほうが重要だ。その意味で、基礎を固めながら書けるところだけ書くのは現実的な戦略となる。

たいていのテストハーネスにはチュートリアルが整備されているので、まったく書いたことがない方はそこから始めるのがいいだろう。

というのも「テストがないコードベースにテストを追加する」のは実はかなり難度が高い。次が主な理由だ。

- そのようなコードベースでは得てしてテストを書きやすい部分が少ないこと
- 書きやすいところを見分けるための知識と経験がメンバーに蓄積されていない可能性が高いこと
- テストを書くためにコードを変更したい場合、その変更がプロダクトを壊していないことを確かめるためのコストが高いこと
  - 手動テストでカバーする場合、何度も変更とテストを繰り返すため時間コストが高い
  - 自動テストを用いる場合、必要な知識と経験が増えてしまうこと

どのようにテストを拡充していくかについてはレガシーコード改善ガイドが詳しい。

https://www.shoeisha.co.jp/book/detail/9784798116839

オブジェクト指向全盛期に書かれた本だが、エッセンスはその他のパラダイムでも使えるはずだ。

#### コアドメインを優先して書く

ここでいう[コアドメインとは DDD で定義されているもの](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap3.html#CoreDomain)だ。経営的には投資対象であり金のなる木であり企業の存在価値となりうるものだ。

意図通りにコアドメインを表現できていなければ、プロダクトとして成立しないはずだ。逆に言えば、これこそが優先的に自動テストの対象とすべき理由となる。自動テストをツールとして用いることでコアドメインの機微を明文化する。

コストパフォーマンスが高いことも理由として大切だろう。後述するように、自動テストを動く仕様書として考えた場合、コアドメインの仕様がわかる資料の作成と品質保証活動を同時に実施可能となる。

また、[クリーンアーキテクチャー](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)や DDD など複数の層構造を持つ設計論を採用する場合、最も自動テストが書きやすい。というのも、それらの設計論においてはまったく依存を持たない層となるため、必然、自動テストを書く難度が低くなる。次の図における最も内側の円の部分がここにあたる。

![The Clean Architecture](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg =480x)

コアドメインはテストカバレッジ 100% とすることを目指すと良い。ここで対象としている[カバレッジ基準](https://en.wikipedia.org/wiki/Code_coverage#Basic_coverage_criteria)はできれば分岐カバレッジや条件カバレッジとしたい。これが難しい場合、それはコアドメインではない可能性がある。

#### UI のテストを書く

自分でハードウェアから作らない限り、 UI は既存の仕組みの上に作っていくことになる。必然、フレームワークやライブラリーなどに依存する必要が出てくる。

これは非常に自動テストを書きづらい。フレームワークやライブラリーのテストをしたいわけではないが、自動テストを書こうとするとそれらも含んだものになりがちだ。

こういった場合は[ハンブルオブジェクト](https://martinfowler.com/bliki/HumbleObject.html)という概念を用いて、描画ロジックを対象とした自動テストを書くと良い。実際の例として React におけるハンブルオブジェクトの活用は次で紹介している。

https://zenn.dev/beingish/articles/03ad6ff736a8cf

#### UX を可視化する

今までの話題は「正しく作る」ための方法、この話題は「正しいものを作る」ための方法論となり、そもそも毛色が違う。品質保証の言葉を使うと [Verification & Validation](https://en.wikipedia.org/wiki/Verification_and_validation) でいうところの Validation の部分にあたる。

UX など人間の感覚については、人間を通してしか可視化できない。そのために[ユーザーリサーチ](https://en.wikipedia.org/wiki/User_research)を実施する必要があるが、手動と自動それぞれで得られるものが異なる。

T.B.D.

### テスティングトロフィー

E2E テストは依存しているものが多い。それらが知らないうちに変更されてしまう確率が高く、壊れやすい。

[テスティングトロフィー](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)を意識してテストを拡充していく。どこまでの品質が必要かによっても異なるが、自動化にあたって必要なものはすべて網羅されている。

https://twitter.com/kentcdodds/status/960723172591992832

個人的な解釈だが、この概念はテストの量は次の順にしていくのが望ましいというひとつの尺度だ。

1. ユースケースとして意味のある粒度でのユニットテスト
2. 型チェック、静的解析
3. ユースケースより細かい粒度でのユニットテスト
4. [コンバージョン](https://en.wikipedia.org/wiki/Conversion_marketing)が可能であることを確かめる E2E テスト
   - 業種によっては[スモークテスト](https://developer.mozilla.org/ja/docs/Glossary/Smoke_Test)と呼ばれることもある

重要度としてはもちろん「コンバージョンが可能であることを確かめる E2E テスト」が最も高い。ここは壊れないように細心の注意を払う必要がある。

## 動く仕様書

ユニットテストにはかなりの情報が詰められている。

- ユースケース
  - どう動くのが正しいのか？
  - 特にドメイン層の情報が蓄積されることはコアコンピタンスの強化につながる
- 異常系の定義
  - どう動いたら正しくないのか？
- 関数の使い方

情報の信頼性はテストが成功しているかどうかでわかる。

また、テストにはプロダクトがどう動くべきなのかの合意があるため、挙動が難しい。

## 設計のためのツール

### TDD の旨味

[TDD](https://speakerdeck.com/twada/tdd-live-in-50-minutes) を実施するためのテストという位置づけもある。 TDD は次の旨味がある。

- テストを書きやすい = 設計として良さそう
  - テストが書きづらい状況は得てして良くない状態になっている
    - いろいろなものが密結合
    - 関数などの使い方が複雑すぎる
  - テストが書きやすいようにコードをリファクタリングすることによって適切な設計、少なくともコントロール可能な設計がなされていく
- 書いたコードが動くことをその場で実感できる
  - テストランナーを使用することで即座に結果を得ていく
    - 人間のワーキングメモリーに負荷をかけないため、設計にパワーを割ける
    - 動くと嬉しくてモチベーションが向上する
    - 学習効率が向上する
  - 意図通りに動かないこと場合すぐ気付ける
    - 開発効率向上
      - [その場で気付けないことによる修正コストは非常に高い](https://www.ipa.go.jp/archive/files/000049404.pdf)

即座に TDD を習得するのは難しいが、実践してみる価値はある。次の動画が参考になる。

[TDD Boot Camp 2020 Online #1 基調講演/ライブコーディング](https://www.youtube.com/watch?v=Q-FJ3XmFlT8)

# フロントエンド特有の事情

フロントエンドは非常に不安定な領域だ。それは主に次の要因による。

- 依存パッケージの多さ
- 描画ライブラリーとの密結合
- 外界からの影響
- 価値創出のための探索

## 依存の多さ

ざっと挙げるだけで次のものがある。

- 描画ライブラリー
- リソース用ライブラリー
  - 画像
  - 動画
  - PDF
  - QR コード
- クラッシュ情報送信
- i18n
- 開発ツール
  - テストフレームワーク
  - 静的解析ツール

これらすべてに対し、次の観点でチェックしなければならない。

- 意図通りに動くこと
- 判明している脆弱性が含まれていないこと

現実的に対応するためにはリグレッションテストを自動化しなければならない。

## 描画ライブラリーとの密結合

描画は結果を得るためのコストが高く、バグが発生したときの追跡コストが大きい。そのため一般的に [Humble Object](https://martinfowler.com/bliki/HumbleObject.html) というアイディアを用いて対処される。

React における Humble Object の利用は次のようになる。

[Custom Hooks as Presenter という考え方](https://zenn.dev/beingish/articles/03ad6ff736a8cf)

また、見え方が意図通りかという課題はそのまま扱うことが難しい。これは分割統治を用いて、 UI コンポーネントとしてより小さな粒度で見た目を担保することで画面全体の品質を確保する。

分割統治にあたってよく用いられている手段には次のようなものがある。

- 契約による設計
- デザインシステム

## 外界からの影響

システム外からのデータに対して適切に対処しなければならない。

- 非同期入出力が必要な周辺コンポーネント
  - 通信
  - ディスク I/O
  - ドングル
- 外部 API
  - 仕様変更
  - 一時的なサービス停止

一般的に[腐敗防止層](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap3.html#AnticorruptionLayer)を設けて対処するが、想定していないデータが渡された際の挙動を事前にテストなどで確認しておく必要がある。

## 価値創出のための探索

プロダクトが意味あるものとなるためには様々な試行が必要となる。そのためにプロダクト自体が容易に変化可能でなければならない。

いざ変化させたときに担保しなければならない点は次。

- 意図した変化であること
  - プロダクト開発にあたっては [V モデル](https://dev.to/sardarmudassaralikhan/v-model-used-in-software-development-1c9)における Verification にあたる
  - ( 探索の結果として、プロダクトが正しいものとなっているかの検証は Validation )
- 変化対象以外が壊れていないこと

[ドッグフーディング](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)など。

# 戦術

## ユニットテスト

### 拡張子は `.test.ts` もしくは `.spec.ts` とする

- テストケースとして仕様を記述できるようであれば `.spec.ts` とする
- それ以外は `.test.ts` とする

迷ったら `.test.ts` で良い。

### テスト対象と同じ階層に置く

次の構成は NG 。

```
src/
├── __test__/
│   └── domain/
│       ├── entity/
│       │   └── account.test.ts
│       └── usecase/
│           └── authentication.test.ts
└── domain/
    ├── entity/
    │   └── account.ts
    └── usecase/
        └── authentication.ts
```

次のような構成を OK とする。

```
src/domain
├── entity/
│   ├── account.ts
│   └── account.test.ts
└── usecase/
    ├── authentication.ts
    └── authentication.test.ts
```

テスト対象から離れていると、テストが書かれているかどうかがわかりづらいため。

## E2E テスト

### 拡張子は `.test.ts` もしくは `.spec.ts` とする

- テストケースとして仕様を記述できるようであれば `.spec.ts` とする
- それ以外は `.test.ts` とする

迷ったら `.test.ts` で良い。

### `/e2e` ディレクトリー以下に置く

テスト対象がファイルではなく、ユーザーストーリーの粒度になるため、ユニットテストと同様の考え方は使えない。

動作を担保すべきユーザーストーリーに絞っていく。

# レガシーコードにテストを書いていく

-
