---
title: "自動テストの戦略と戦術"
emoji: "💯"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["test"]
published: true
publication_name: "beingish"
---

聞かれることが多いので文章としてまとめておく。参照しながら説明するための資料となる。

私の立ち位置を明らかにしておくと、「好みの問題」になるまでは原理主義的に自動テスト化を推し進めるべきだと思っている。

が、組織やチームによってそのラインも異なるし、もちろん異なるスタンスの方もいるので臨機応変に使えるものを使えば良い。道具は人間の可能性を制限してはならない。

内容は[和田拓人](https://twitter.com/t_wada)さんの教えからの我流なので、少しでも気になる情報があれば、一次情報にあたる意味でも彼からの発信を追うと良い。もちろん、矛盾や不備などは我流部分なので指摘は私へ。

なお、戦術という言葉は「コードベースに携わるチームが目標を達成するためのレイヤー」という意味で、戦略という言葉は「チームも含めた集団全体の目標を達成するためのレイヤー」という意味で使っている。裏返すと、ここで戦略として書いたことはエンジニアでなくても理解可能、かつ理解しておいたほうが良い内容となっている。

# 3 行まとめ

## 戦略

1. 常に目的をはっきりさせる
   - 品質保証
   - 動く仕様書
   - 設計のためのツール
1. 全自動化にこだわらない
1. CI: Continuous Integration

## 戦術

1. テスティングトロフィー
1. フレームワークや UI ライブラリーが密接に絡む箇所は Humble Object の考え方を使う
1. 分割統治

- モックとの付き合い方
  - 外部とのインタラクションが発生する部分
    - ネットワーク通信

# 戦略

## 常に目的をはっきりさせる

あるコードベースに自動テストが存在することは、人間にとって次の旨みがある。

1. 品質保証
1. 動く仕様書
1. 設計のためのツール

組織目標を達成するために、これらのメリットをどのように使うかを意識すると良い。楽をしようとするなら総取りが良いが、それぞれで学習が必要なため徐々にやっていこう。

### 品質保証

自動テストは[品質保証](https://en.wikipedia.org/wiki/Quality_assurance)の一部、ソフトウェアテストのさらに一部として定義されている。そのため、やるかやらないかではなく「どこまでやるか」を決めることになる。

存在する自動テストをすべてパスしていればプロダクトの目標を達成している、これが理想の状態だ。ただし現代で理想を実現するのは現実的に不可能なので、組織目標とコストを勘案しながら決めることになる。

:::details 理想の実現が不可能な理由
最も大きいのは人間への理解が十分でないため、目標を定めづらいことだろう。現状、プロダクトごとにユーザーリサーチが必要になる。これは求める品質が不明確であることの証左だ。人間がどのように変化するかも含めての理解が人類になければ、自動化は不可能だ。

また、理想を実現するために必要なコストが莫大となることも現実的な課題だ。目標を達成しているかの検証を自動化するのはコストパフォーマンスが低い。
:::

他の目標との兼ね合いもあるが、おおむね次に挙げる段階があるだろう。

1. 書けるところだけ書く
1. コアドメインのテストを書く
1. UI のテストを書く
1. UX を可視化する

#### 書けるところだけ書く

コードベースの大きさによらず、テストハーネスの導入など土台の整備と、その動作確認のための簡単な自動テストを最優先で用意しよう。

たいていのテストハーネスにはチュートリアルが整備されているので、まったく書いたことがない方はそこから始めるのがいいだろう。

また、「テストがないコードベースにテストを追加する」のは実はかなり難度が高い。次が主な理由だ。

- そのようなコードベースでは得てしてテストを書きやすい部分が少ないこと
- 書きやすいところを見分けるための知識と経験がメンバーに蓄積されていない可能性が高いこと
- テストを書くためにコードを変更したい場合、その変更がプロダクトを壊していないことを確かめるためのコストが高いこと
  - 手動テストでカバーする場合、何度も変更とテストを繰り返すため時間コストが高い
  - 自動テストを用いる場合、必要な知識と経験が増えてしまうこと

どのように自動テストを導入するかについてはレガシーコード改善ガイドが詳しい。

https://www.shoeisha.co.jp/book/detail/9784798116839

オブジェクト指向全盛期に書かれた本だが、エッセンスはその他のパラダイムでも使えるはずだ。

ここまでできていれば、徐々に自動テストは増えていく。不安に感じている部分のテストを厚く書いたり、トラブルの再発を防止するためにテストケースを追加したりなどだ。テストを書きたいと思った際にすぐ書ける状況を維持しておくのが最も重要だ。こういった意味で基礎を固めながら書けるところだけ書くのは現実的な戦略だ。

#### コアドメインを優先して書く

ここでいう[コアドメインとは DDD で定義されているもの](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap3.html#CoreDomain)だ。経営的には投資対象であり金のなる木であり企業の存在価値となりうるものだ。

意図通りにコアドメインを表現できていなければ、プロダクトとして成立しないはずだ。逆に言えば、これこそが優先的に自動テストの対象とすべき理由となる。自動テストをツールとして用いることでコアドメインの機微を明文化する。

コストパフォーマンスが高いことも理由として大切だろう。後述するように、自動テストを動く仕様書として考えた場合、コアドメインの仕様がわかる資料の作成と品質保証活動を同時に実施可能となる。

また、[クリーンアーキテクチャー](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)や [DDD](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap2.html#LayeredArchitecture) など複数の層構造を持つ設計論を採用する場合、最も自動テストが書きやすい。というのも、それらの設計論においてはまったく依存を持たない層となるため、必然、自動テストを書く難度が低くなる。次の図における最も内側の円の部分がここにあたる。

![The Clean Architecture](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg =480x)

コアドメインはテストカバレッジ 100% とすることを目指すと良い。ここで対象としている[カバレッジ基準](https://en.wikipedia.org/wiki/Code_coverage#Basic_coverage_criteria)はできれば分岐カバレッジや条件カバレッジとしたい。これが難しい場合、それはコアドメインではない可能性がある。

#### UI のテストを書く

自分でハードウェアから作らない限り、 UI は既存の仕組みの上に作っていくことになる。必然、フレームワークやライブラリーなどに依存する必要が出てくる。

これは非常に自動テストを書きづらい。フレームワークやライブラリーのテストをしたいわけではないが、自動テストを書こうとするとそれらも含んだものになりがちだ。

こういった場合は[ハンブルオブジェクト](https://martinfowler.com/bliki/HumbleObject.html)という概念を用いて、描画ロジックを対象とした自動テストを書くと良い。実際の例として React におけるハンブルオブジェクトの活用は次で紹介している。

https://zenn.dev/beingish/articles/03ad6ff736a8cf

#### UX を可視化する

今までの話題は「正しく作る」ための方法、この話題は「正しいものを作る」ための方法論となり、そもそも毛色が違う。品質保証の言葉を使うと [Verification & Validation](https://en.wikipedia.org/wiki/Verification_and_validation) でいうところの Validation の部分にあたる。

UX など人間の感覚については、人間を通してしか可視化できない。そのために[ユーザーリサーチ](https://en.wikipedia.org/wiki/User_research)を実施する必要がある。自動的に実施可能なものはユーザーがどのようにプロダクトを使用しているかなど、データの取得が多く定量分析に適している。 Web やモバイルアプリの文脈ではいわゆるアクセス解析と呼ばれるようなものや、フィードバックを入力させる仕組みなどが具体的な例だ。

習熟すれば、想定通りにユーザーがプロダクトを使うか、それを価値と感じるかなどを間接的に知ることができる。

ただし、思い込みの排除や文脈の補完のために、ユーザーインタビューなどを用いて自動的に
は取得不可能なデータを集めるのが良いだろう。特に最近は[パラレルインタラクション](https://bnn.co.jp/products/9784861009389)を意識したほうが良いため、ユーザーがどのような環境に身を置いているのかは積極的に収集するとよいだろう。

## 動く仕様書

自動テストにはかなりの情報が詰められている。

- ユースケース
  - どう動くのが正しいのか？
  - 特にドメイン層の情報が蓄積されることはコアコンピタンスの強化につながる
- 異常系の定義
  - どう動いたら正しくないのか？
- 関数の使い方
  - [契約による設計](https://en.wikipedia.org/wiki/Design_by_contract)などを厳密に適用できない場合でもテストケースで説明できる

情報の信頼性はテストが成功しているかどうかでわかる。

プロダクトやコードベースを理解するためにこれらの情報を使おう。テストケース名は自然言語で書けるため、ステイクホルダーと一緒に眺めて共通認識を作ることができる。また、チームの新メンバーに自動テストを見てもらうのはオンボーディングとして効率的な手段だ。

テストコードを眺めていると、やりすぎだと感じたり、手薄で不安だと感じるところもあるだろう。こういった感覚は無視するべきでない。普段実行するテストケースを絞ったり、テストケースをブレイクダウンして不安を払拭するなどの活動につなげるとよいだろう。

## 設計のためのツール

自動テストには [TDD](https://speakerdeck.com/twada/tdd-live-in-50-minutes) を実践するためという位置づけもある。 TDD は次の旨味がある。

- テストを書きやすい = 設計として良さそう
  - 次のような、テストが書きづらい状況は得てして良くない状態になっている
    - いろいろなものが密結合してしまっている
    - 関数やクラスなどの使い方が複雑すぎる
  - テストが書きやすいようにコードをリファクタリングすることによって、少なくともコントロール可能な設計がなされていく
- 書いたコードが動くことをその場で実感できる
  - テストランナーを使用することで即座に結果を得ていく
    - [ワーキングメモリー](https://en.wikipedia.org/wiki/Working_memory)に負荷をかけないため、設計にパワーを割ける
    - 動くと嬉しくてモチベーションが向上する
    - 学習効率が向上する
  - 意図通りに動かない場合すぐ気付ける
    - 開発効率向上
      - [その場で気付けないことによる修正コストは非常に高い](https://www.ipa.go.jp/archive/files/000049404.pdf)

即座に TDD を習得するのは難しいが、実践してみる価値はある。まず次の動画で「極める」とどうなるかを見てみると良い。

[TDD Boot Camp 2020 Online #1 基調講演/ライブコーディング](https://www.youtube.com/watch?v=Q-FJ3XmFlT8)

https://shop.ohmsha.co.jp/shopdetail/000000004967/

## 全自動化にこだわらない

整理しながらという前提付きで、自動テストは書けば書くほど良い。プロジェクトに関する様々な知識が得られ、開発者の経験値が貯まり、いいことづくめだ。

ただし、自動テスト以外の方法を採用するとコストパフォーマンスが良い場合もある。特に UX 領域は顕著にその傾向がある。ユーザーインタビューの実施もコストが高いため、まず[ドッグフーディング](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)など手元で実施できることを検討してみよう。

自動テストに関するチームメンバーの学習コストを現実的な時間で払いきれない、という場合も手動テストやその他で賄って良い。が、少なくとも応急手当であること、できれば今後の予定などはチームで共有しておこう。

## CI: Continuous Integration

# フロントエンド特有の事情

フロントエンドは非常に不安定な領域だ。それは主に次の要因による。

- 依存パッケージの多さ
- 描画ライブラリーとの密結合
- 外界からの影響
- 価値創出のための探索

## 依存の多さ

ざっと挙げるだけで次のものがある。

- 描画ライブラリー
- リソース用ライブラリー
  - 画像
  - 動画
  - PDF
  - QR コード
- クラッシュ情報送信
- i18n
- 開発ツール
  - テストフレームワーク
  - 静的解析ツール

これらすべてに対し、次の観点でチェックしなければならない。

- 意図通りに動くこと
- 判明している脆弱性が含まれていないこと

現実的に対応するためにはリグレッションテストを自動化しなければならない。

## 描画ライブラリーとの密結合

描画は結果を得るためのコストが高く、バグが発生したときの追跡コストが大きい。そのため一般的に [Humble Object](https://martinfowler.com/bliki/HumbleObject.html) というアイディアを用いて対処される。

React における Humble Object の利用は次のようになる。

[Custom Hooks as Presenter という考え方](https://zenn.dev/beingish/articles/03ad6ff736a8cf)

また、見え方が意図通りかという課題はそのまま扱うことが難しい。これは分割統治を用いて、 UI コンポーネントとしてより小さな粒度で見た目を担保することで画面全体の品質を確保する。

分割統治にあたってよく用いられている手段には次のようなものがある。

- 契約による設計
- デザインシステム

## 外界からの影響

システム外からのデータに対して適切に対処しなければならない。

- 非同期入出力が必要な周辺コンポーネント
  - 通信
  - ディスク I/O
  - ドングル
- 外部 API
  - 仕様変更
  - 一時的なサービス停止

一般的に[腐敗防止層](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap3.html#AnticorruptionLayer)を設けて対処するが、想定していないデータが渡された際の挙動を事前にテストなどで確認しておく必要がある。

## 価値創出のための探索

プロダクトが意味あるものとなるためには様々な試行が必要となる。そのためにプロダクト自体が容易に変化可能でなければならない。

いざ変化させたときに担保しなければならない点は次。

- 意図した変化であること
  - プロダクト開発にあたっては [V モデル](https://dev.to/sardarmudassaralikhan/v-model-used-in-software-development-1c9)における Verification にあたる
  - ( 探索の結果として、プロダクトが正しいものとなっているかの検証は Validation )
- 変化対象以外が壊れていないこと

[ドッグフーディング](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)など。

# 戦術

## 習得

自動テストを書くというのはひとつのスキルだ。習得するために学習や経験が必要となる。その際のトピックとして主に次が挙げられる。網羅されてはいないため、取っ掛かりていどに捉えると良い。

- 基礎
  1. テストハーネスの導入
     - テスティングフレームワークの導入と初期設定
     - テスト用ライブラリーのインストールと設定
  1. テストハーネスの使い方
     - テストの書き方
     - テストの実行方法
       - 必要なテストのみ実行する方法
  1. [テストサイズ](https://testing.googleblog.com/2010/12/test-sizes.html)の概念
  1. [テストカバレッジ](https://en.wikipedia.org/wiki/Code_coverage)
     - カバレッジ基準
- 発展
  1. モックの使い方
     - 接合モデル
  1. UI のテスト
     - [ハンブルオブジェクト](https://martinfowler.com/bliki/HumbleObject.html)
  1. テストがないコードベースにテストを追加する
     - [スプラウト系](https://dev.to/edgaremmanuel/changing-software-sprout-method-1iok)

これだけ多いとハードルが高く感じられるが、まず基礎を確実に抑えよう。発展トピックはそれぞれ必要になったら学ぶで良い。

## テスティングトロフィー

E2E テストは依存しているものが多い。それらが知らないうちに変更されてしまう確率が高く、壊れやすい。

[テスティングトロフィー](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)を意識してテストを拡充していく。どこまでの品質が必要かによっても異なるが、自動化にあたって必要なものはすべて網羅されている。

https://twitter.com/kentcdodds/status/960723172591992832

個人的な解釈だが、この概念はテストの量は次の順にしていくのが望ましいというひとつの尺度だ。

1. ユースケースとして意味のある粒度でのユニットテスト
2. 型チェック、静的解析
3. ユースケースより細かい粒度でのユニットテスト
4. [コンバージョン](https://en.wikipedia.org/wiki/Conversion_marketing)が可能であることを確かめる E2E テスト
   - 業種によっては[スモークテスト](https://developer.mozilla.org/ja/docs/Glossary/Smoke_Test)と呼ばれることもある

重要度としてはもちろん「コンバージョンが可能であることを確かめる E2E テスト」が最も高い。ここは壊れないように細心の注意を払う必要がある。

## ユニットテスト

### 拡張子に意味をもたせる

例えば TypeScript では `.test.ts` もしくは `.spec.ts` などとする。

- テストケースとして仕様を記述できるようであれば `.spec.ts` とする
- それ以外は `.test.ts` とする

### テスト対象と同じ階層に置く

次の構成は NG 。

```
src/
├── __test__/
│   └── domain/
│       ├── entity/
│       │   └── account.test.ts
│       └── usecase/
│           └── authentication.test.ts
└── domain/
    ├── entity/
    │   └── account.ts
    └── usecase/
        └── authentication.ts
```

次のような構成を OK とする。

```
src/
└── domain/
    ├── entity/
    │   ├── account.ts
    │   └── account.test.ts
    └── usecase/
        ├── authentication.ts
        └── authentication.test.ts
```

理由は 2 つ。

1. 自動テスト内でテスト対象のコードを読み込む際のパス指定が煩雑になりがち
2. テストが書かれているかどうかがディレクトリーツリーからではわかりにくい

## E2E テスト

### 拡張子は `.test.ts` もしくは `.spec.ts` とする

- テストケースとして仕様を記述できるようであれば `.spec.ts` とする
- それ以外は `.test.ts` とする

迷ったら `.test.ts` で良い。

### `/e2e` ディレクトリー以下に置く

テスト対象がファイルではなく、ユーザーストーリーの粒度になるため、ユニットテストと同様の考え方は使えない。

動作を担保すべきユーザーストーリーに絞っていく。

# レガシーコードにテストを書いていく

-
