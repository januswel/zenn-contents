---
title: "Technology Radar Volume 31 まとめ"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [technologyradar, curation]
published: true
publication_name: "beingish"
---

[2024 年 10 月 23 日公開](https://www.thoughtworks.com/content/dam/thoughtworks/documents/radar/2024/10/tr_technology_radar_vol_31_en.pdf)。

https://www.thoughtworks.com/radar

[Technology Radar についてはここにまとめている](https://zenn.dev/januswel/articles/d3b2c23bcbcd6f)。

この記事では次のことがわかる。

1. 今号のテーマ
2. 各カテゴリーごとの Adopt / Hold / ピックアップを紹介
   - ピックアップは将来的に影響がありそうなものや面白そうなものを選んでいる
   - 個人的な思いなども書いているので参考に

## その他のまとめ

- [Volume 28](https://zenn.dev/beingish/articles/93d6a1a62ba100)
- [Volume 29](https://zenn.dev/beingish/articles/edb33ee3775169)
- [Volume 30](https://zenn.dev/beingish/articles/554260542fced5)

## 今号のテーマ

### Coding assistance antipatterns: コーディング補助のアンチパターン

GitHub Copilot など、コーディング向けのツールが提案してくるコードは一見良さそうに見える。特に、入力と出力が決まり切った関数や単純なテストケースにおける自動テストなどはそのまま使えるものも多い。

ただし、長期的にコードベースの健全性を保つためには、あくまでひとつの提案として受け止め、エンジニアがすべてをわかったうえできちんと式の細部まで決定する必要がある。

というのも、依然として開発はチームでなされるものだからだ。いくらツールの補助を得たとしてもひとりで開発できる分量はプロダクトして十分とはいえない。チームという文脈において、自分が書いたコードのチームに対する説明責任は自分にある。生成してもらったコードだから代案とどちらが良いか判断できない、という状況ではエンジニアは名乗れないだろう。

個人的にも、あくまでコーディングを補助するツールは自らの理解を補ったり、最初の取っ掛かりを得るためのものとして割り切ったほうが良い、という感じている。

このテーマではこういったツールを使う際は、自動テストや[アーキテクチャー適合関数](https://medium.com/yonder-techblog/architectural-fitness-functions-an-intro-to-building-evolutionary-architectures-dc529ac76351)、ペアプログラミングなどによるコードベースの品質担保も同時に実施したほうが良いと書かれている。

### Rust is anything but rusty: Rust は全く錆びつかない

Rust 最高、というテーマ。主に実行速度面でのメリットが取り上げられているようだ。

所有権について理解ができれば、メモリー管理の効率の良さも含めて良い選択肢になるだろう。

### The gradual rise of WASM: WASM の段階的な台頭

WASM が徐々に使えるようになってきたというテーマ。

Rust だけでなく、 C++ などすでに幅広く使われている言語で書いたものもブラウザー上で実行可能な環境が整ってきた。

[古くは Emscripten を用いてゲームをブラウザー上で動かすなどもされてきた](https://app.famitsu.com/20161107_849726/)が、ここまでの苦労をせずともアーキテクチャーとして検討可能となってきた。

### The Cambrian explosion of generative AI tools: 生成 AI ツールのカンブリア爆発

生成 AI に関連するツールが数多く登場していることを[カンブリア爆発](https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%96%E3%83%AA%E3%82%A2%E7%88%86%E7%99%BA)になぞらえたテーマ。

過去数回の Technology Radar でも生成 AI 関連のツールが blip としてたくさん載っていたが、それらの登場は必然で、この傾向もしばらく続くだろうと述べられている。

## Techniques

### Adopt

#### 1% canary: 1% のカナリア

既存ユーザーの 1% 程度のセグメントに次期バージョンのソフトウェアをリリースし、影響や反応を見ることらしい。

これは A/B テストなどと目的が違う。モバイルアプリや IoT 、車載組み込みのソフトウェアなどが対象であり、安全にバージョンアップやその後の運用ができることを確かめるためのものであるということだ。

基本的にモバイルや組み込みはアップデート難度が高い。失敗した場合文鎮化する可能性もあるし、アップデートに伴ってデータ変換が必要な場合は再入可能としておく必要もある。それでも OTA アップデートなどが使える場合など、昔に比べたら難度は下がっているが、回収コストなどが発生する可能性も考えると甘く見ないほうがいい。

1% canary はこういったリスクをある程度減らしてくれるテクニックだ。

#### Component testing: コンポーネントテスト

UI コンポーネントにおける、テストサイズ小での自動テストを推奨する blip 。

ブラウザーベースの描画テストはわかりやすいが、不安定で時間もかかる。 Chromium を使ったビジュアルリグレッションテストも成熟してきた感じがあるが、 CI ごとに変更が意図的かどうかの確認をしなければならないことには賛否両論あるだろう。というわけで最初から意図を織り込め、実行時間も短いテストサイズ小に切り分けたほうがメリットも多いという主張のようだ。

コンポーネントのテストをテストサイズ小へ収めるために、どう書けばいいのかわからない場合は次が参考になるだろう。

https://zenn.dev/beingish/articles/03ad6ff736a8cf

#### Continuous deployment: 継続的デプロイ

[continuous delivery: 継続的デリバリーと混同されがちだが、明確に次の違いがある](https://martinfowler.com/bliki/ContinuousDelivery.html)。

- 継続的デリバリーはデプロイパイプラインが自動化されていること
- 継続的デプロイメントはすべての変更が自動的に本番リリースされること

https://www.oreilly.com/library/view/continuous-deployment/9781098146719/

実はこの号で Adopt 入り。全組織が適用すべきプラクティスだとする根拠が最近得られたのだろう。

が、実現までは非常にハードルが高い。意図した変更であることを自動的に確認できなければならない、品質を自動的に担保できなければならないなど、エンジニアだけでなく多くの方の協力がなければ実現できないからだ。

#### Retrieval-augmented generation (RAG)

前回も Adopt だったが、引き続きの登場となる。

ThoughtWorks 内でもいろいろ使われているようで、 LLM ベースで何か作る際は RAG をまず検討するのが良いらしい。

### Hold

#### Complacency with AI-generated code: AI が生成したコードへの満足

今号のテーマにもあった通り、 AI が生成したコードを全面的に信用してはならない。提案されたコードを理解するにも、量が多いと難しいため使うところは弁えると良いだろう。

#### Enterprise-wide integration test environments: 企業全体の統合テスト環境

いわゆるマイクロサービスで構築されたプロダクトにおいては、すべてのサービスにおけるテスト環境を永続的に確保しておくことはひとつの選択肢だった。が、それは開発効率の悪化につながるという blip 。

モノリスやモジュラーモノリスであれば環境をすぐに作れるようにしやすいため、あまり問題にならない、はず。

#### LLM bans: LLM 禁止

当初 LLM に入力したプロンプトなどを学習データとして用いる懸念があったため、一律使用を禁止した企業もあっただろう。また、生成された内容が著作権やライセンスに違反していないかというリスクを許容できるかどうかについても十分検討する必要があった。

最近ではそういった疑念が払拭されつつある。例えば Microsoft は GitHub Copilot ユーザーの法的リスクを軽減する姿勢を打ち出している。

https://news.microsoft.com/ja-jp/2023/09/12/230912-copilot-copyright-commitment-ai-legal-concerns/

あくまでツールなのでメリットとデメリットを比較して使用するかを決めればよいが、一律で使用を禁止するフェイズではなくなってきたということだろう。 LLM を使わない場合、業務効率が「落ちる」という感覚になってきた。

ツールを提供している企業が「秘密情報を適切に取り扱っている」と言うなら信用するしかない状況なのは LLM に限らず同じ状況だろう。 Google Workspace には秘密情報を山ほど集積しているわけだし…。

#### Replacing pair programming with AI

コーディング用の LLM を用いることをペアプログラミングとは呼べない、という blip 。

そもそもペアプログラミングやモブプログラミングには次のメリットがある。

1. ひとりでは手に余る課題へ、複数の思考とコラボレーションによって対応できる
1. 課題解決の経験をチームメンバーと共有できる
1. 片方のチームメンバーからその他のチームメンバーへ、スキルトランスファーできる
1. 役立つツールやプロダクト固有の事情などを教えあえる

が、 AI とのみ会話していると最初のメリットの半分くらいしか享受できない。

そもそも違うものとして捉えた方が良いということになる。

### ピックアップ

#### LLM as a judge

#### Using GenAI to understand legacy codebases

#### AI team assistants

## Platforms

### Adopt

### Hold

### ピックアップ

## Tools

### Adopt

### Hold

### ピックアップ

## Languages & Frameworks

### Adopt

### Hold

### ピックアップ
